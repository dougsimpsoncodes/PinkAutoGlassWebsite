import { NextResponse } from "next/server";
import { cookies, headers } from "next/headers";
import { BookingSchema, parseRelativeDate, normalizePhoneE164 } from "../../../../lib/booking-schema";
import { supabase, checkRateLimit, validateFile, STORAGE_CONFIG } from "@/lib/supabase";

export async function POST(req: Request) {
  try {
    // Rate limiting - 5 submissions per minute per IP
    const h = headers();
    const ip_address = h.get("x-forwarded-for") || h.get("x-real-ip") || "unknown";
    
    const rateLimit = checkRateLimit(ip_address, 5, 60000); // 5 requests per minute
    if (!rateLimit.allowed) {
      return NextResponse.json(
        { 
          ok: false, 
          error: "Too many requests. Please wait before submitting again.",
          retryAfter: Math.ceil((rateLimit.resetTime! - Date.now()) / 1000)
        }, 
        { 
          status: 429,
          headers: {
            'Retry-After': Math.ceil((rateLimit.resetTime! - Date.now()) / 1000).toString()
          }
        }
      );
    }
    const raw = await req.json();
    const parsed = BookingSchema.parse(raw);

    const termsAccepted =
      parsed.terms_accepted ??
      parsed.termsAccepted ??
      parsed.privacy_acknowledgment ??
      parsed.privacyAcknowledgment ??
      false;

    const preferred_date = parseRelativeDate(parsed.preferred_date);
    const phone_e164 = normalizePhoneE164(parsed.phone);

    const c = cookies();
    const client_id = c.get("cid")?.value || null;
    const session_id = c.get("sid")?.value || null;
    const ft = c.get("ft")?.value ? JSON.parse(c.get("ft")!.value) : null;
    const lt = c.get("lt")?.value ? JSON.parse(c.get("lt")!.value) : null;

    const payload = {
      service_type: parsed.service_type,
      mobile_service: !!parsed.mobile_service,
      first_name: parsed.first_name,
      last_name: parsed.last_name,
      phone: parsed.phone,
      phone_e164,
      email: parsed.email,
      vehicle_year: parsed.vehicle_year,
      vehicle_make: parsed.vehicle_make,
      vehicle_model: parsed.vehicle_model,
      address: parsed.address,
      city: parsed.city,
      state: parsed.state?.toUpperCase(),
      zip: parsed.zip,
      preferred_date,
      time_preference: parsed.time_preference,
      notes: parsed.notes,
      sms_consent: !!parsed.sms_consent,

      terms_accepted: !!termsAccepted,
      privacy_acknowledgment: !!termsAccepted,

      source: parsed.source || lt?.utm?.source || ft?.utm?.source || "website",
      status: "new",
      ip_address,
      referral_code: parsed.referral_code || null,
      client_id,
      session_id,
      first_touch: ft,
      last_touch: lt
    };

    const { data: lead, error } = await supabase
      .from("leads")
      .insert(payload)
      .select("id, session_id")
      .single();

    if (error) return NextResponse.json({ ok:false, error: error.message }, { status: 400 });

    const inserts: any[] = [];
    if (ft) inserts.push({
      lead_id: lead.id,
      session_id: lead.session_id,
      touch_type: "first",
      utm: ft.utm || {},
      click_ids: ft.click_ids || {},
      channel: null,
      referrer: ft.referrer || null,
      landing_page: ft.landing_page || null
    });
    if (lt) inserts.push({
      lead_id: lead.id,
      session_id: lead.session_id,
      touch_type: "last",
      utm: lt.utm || {},
      click_ids: lt.click_ids || {},
      channel: null,
      referrer: lt.referrer || null,
      landing_page: lt.landing_page || null
    });
    if (inserts.length) await supabase.from("lead_attributions").insert(inserts);

    // Handle photo uploads if provided
    if (parsed.files && Array.isArray(parsed.files)) {
      // Validate file count
      if (parsed.files.length > STORAGE_CONFIG.MAX_FILES_PER_UPLOAD) {
        return NextResponse.json({
          ok: false,
          error: `Too many files. Maximum ${STORAGE_CONFIG.MAX_FILES_PER_UPLOAD} files allowed.`
        }, { status: 400 });
      }

      const mediaInserts = [];
      
      for (const file of parsed.files) {
        // Create a mock File object for validation
        const mockFile = {
          size: file.size,
          type: file.type,
          name: file.name
        } as File;

        // Validate file
        const validation = validateFile(mockFile);
        if (!validation.valid) {
          return NextResponse.json({
            ok: false,
            error: `File "${file.name}": ${validation.error}`
          }, { status: 400 });
        }

        // Validate base64 data format
        if (!file.data || !file.data.includes(',')) {
          return NextResponse.json({
            ok: false,
            error: `Invalid file data format for "${file.name}"`
          }, { status: 400 });
        }

        // Extract base64 data
        const base64Data = file.data.split(',')[1];
        if (!base64Data) {
          return NextResponse.json({
            ok: false,
            error: `Invalid base64 data for "${file.name}"`
          }, { status: 400 });
        }

        const buffer = Buffer.from(base64Data, 'base64');

        // Verify actual file size matches reported size
        if (Math.abs(buffer.length - file.size) > 1000) { // Allow 1KB tolerance for encoding
          return NextResponse.json({
            ok: false,
            error: `File size mismatch for "${file.name}"`
          }, { status: 400 });
        }
        
        // Sanitize filename (remove path traversal, special chars)
        const sanitizedName = file.name
          .replace(/[^a-zA-Z0-9._-]/g, '_') // Replace special chars with underscores
          .replace(/^\.+/, '') // Remove leading dots
          .substring(0, 100); // Limit filename length
        
        // Generate secure unique filename
        const fileName = `${lead.id}/${Date.now()}-${sanitizedName}`;
        
        // Upload to Supabase Storage
        const { data: uploadData, error: uploadError } = await supabase.storage
          .from('damage-photos')
          .upload(fileName, buffer, {
            contentType: file.type,
            upsert: false
          });
        
        if (!uploadError && uploadData) {
          // Get public URL
          const { data: { publicUrl } } = supabase.storage
            .from('damage-photos')
            .getPublicUrl(fileName);
          
          // Save media reference to database
          mediaInserts.push({
            lead_id: lead.id,
            file_name: file.name,
            file_size: file.size,
            mime_type: file.type,
            storage_path: fileName,
            public_url: publicUrl
          });
        }
      }
      
      // Insert all media records
      if (mediaInserts.length > 0) {
        await supabase.from("media").insert(mediaInserts);
      }
    }

    // Trigger email notification (fire and forget)
    fetch(`${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/api/booking/notify`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ leadId: lead.id })
    }).catch(err => console.error('Failed to send notification:', err));

    return NextResponse.json({ ok:true, id: lead.id });
  } catch (e:any) {
    return NextResponse.json({ ok:false, error: e.message || "error" }, { status: 400 });
  }
}
